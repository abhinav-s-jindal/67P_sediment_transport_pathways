"""
Interactive Reverse Trajectory Visualizer for Comet 67P Sediment Transport
===========================================================================

This tool enables interactive analysis of sediment source-target relationships
by allowing users to select target regions and visualize contributing source
facets colored by their particle contribution fractions.

Required Input Files:
--------------------
1. Spatial index (PKL): cell_spatial_index.pkl
   - Pre-computed spatial tree for efficient facet queries
   - Generated by spatial index generator script

2. Transport dictionary (PKL): transport_dict_velocity_0x_shapemodel.pkl
   - Created by running generate_spatial_index.py
   - Source-to-destination facet mappings for selected velocity
   - Located in: transport_dict_files/

3. Shape model (OBJ): CG_s7v1_10Km_16m_13M_B_INLET.obj
   - 3D mesh geometry
   - Located in: obj_files/

Workflow:
---------
1. Select target facets using interactive brush tool
2. Calculate which source facets contribute particles to targets
3. Visualize sources colored by contribution fraction (plasma colormap)
4. Export selection and results to CSV files

Interactive Controls:
--------------------
'p'     - Toggle target selection mode (paint targets in green)
'c'     - Clear selected targets and reset visualization
'v'     - Calculate source contributions and visualize with plasma colormap
'r'     - Reset to original gray surface view
'['']'  - Decrease/increase brush size
's'     - Save target selection and source contributions to CSV
Mouse   - Click and drag to select target facets (when selection mode ON)

Output Files:
-------------
- target_selection_YYYYMMDD_HHMMSS.csv: Selected target facet IDs
- source_contributions_YYYYMMDD_HHMMSS.csv: Source facets with contribution fractions

Author: Abhinav S. Jindal
"""

import vtk
import numpy as np
from time import time
import pickle
import csv
import os
from collections import defaultdict

# ============================================================================
# Configuration
# ============================================================================

TRANSPORT_DICT_DIR = "transport_dict_files"
SHAPE_MODEL_FILE = "obj_files/CG_s7v1_10Km_16m_13M_B_INLET.obj"
SPATIAL_INDEX_FILE = "cell_spatial_index.pkl"

# ============================================================================
# Core Classes
# ============================================================================

class TargetSelector(vtk.vtkCellPicker):
    """Cell picker for interactive target facet selection with brush tool."""
    
    def __init__(self):
        super().__init__()
        self.selected_targets = set()
        self.selection_active = False
        self.brush_radius = 0.1
        self.last_update = 0
        self.update_interval = 0.01
        self.left_button_pressed = False
        self.last_position = None

class ReverseTrajectoryVisualizer(vtk.vtkInteractorStyleTrackballCamera):
    """Main visualizer for reverse trajectory analysis with plasma colormap."""
    
    def __init__(self, selector, renderer, polydata, text_actor, velocity):
        super().__init__()
        self.selector = selector
        self.renderer = renderer
        self.polydata = polydata
        self.text_actor = text_actor
        self.velocity = velocity
        
        # Load spatial index
        print(f"Loading spatial index from {SPATIAL_INDEX_FILE}...")
        with open(SPATIAL_INDEX_FILE, 'rb') as f:
            spatial_data = pickle.load(f)
            self.cell_centers = spatial_data['centers']
            self.spatial_tree = spatial_data['tree']
        print(f"Loaded spatial index for {len(self.cell_centers):,} facets")
        
        # Load transport data for specified velocity
        velocity_str = f"{int(velocity * 10):02d}"
        transport_file = os.path.join(TRANSPORT_DICT_DIR, 
                                     f"transport_dict_velocity_{velocity_str}_shapemodel.pkl")
        print(f"Loading transport data from {transport_file}...")
        with open(transport_file, 'rb') as f:
            self.transport_data = pickle.load(f)
        print(f"Loaded transport data: {len(self.transport_data):,} source facets")
        
        # Visualization state
        self.source_fractions = {}
        self.visualization_active = False
        self.main_actor = None
        self.target_actor = None
        self.source_actor = None
        self.colorbar_actor = None
        
        self.SetCurrentRenderer(renderer)
        
        # Register event callbacks
        self.AddObserver("LeftButtonPressEvent", self.on_left_press)
        self.AddObserver("LeftButtonReleaseEvent", self.on_left_release)
        self.AddObserver("MouseMoveEvent", self.on_mouse_move)

    def get_nearby_facets(self, center_facet_id):
        """Get all facets within brush radius of center facet."""
        if center_facet_id < 0 or center_facet_id >= len(self.cell_centers):
            return set()
        
        center = self.cell_centers[center_facet_id]
        nearby_indices = self.spatial_tree.query_ball_point(center, self.selector.brush_radius)
        return set(nearby_indices)

    def get_facets_between_points(self, start_facet, end_facet):
        """Get all facets within brush radius along line between two facets."""
        if (start_facet < 0 or end_facet < 0 or 
            start_facet >= len(self.cell_centers) or 
            end_facet >= len(self.cell_centers)):
            return set()
            
        start_center = self.cell_centers[start_facet]
        end_center = self.cell_centers[end_facet]
        
        facets = set()
        num_steps = 10
        for i in range(num_steps + 1):
            t = i / num_steps
            interp_point = [s + t * (e - s) for s, e in zip(start_center, end_center)]
            nearby_indices = self.spatial_tree.query_ball_point(interp_point, self.selector.brush_radius)
            facets.update(nearby_indices)
            
        return facets

    def create_plasma_colorbar(self):
        """Create plasma colorbar for source fraction visualization."""
        lut = vtk.vtkLookupTable()
        lut.SetNumberOfTableValues(256)
        lut.SetRange(0.1, 1.0)
        
        for i in range(256):
            val = i / 255.0
            
            if val < 0.25:
                r = 0.05 + 0.5 * (val / 0.25)
                g = 0.0
                b = 0.5 + 0.4 * (val / 0.25)
            elif val < 0.5:
                r = 0.55 + 0.35 * ((val - 0.25) / 0.25)
                g = 0.0 + 0.3 * ((val - 0.25) / 0.25)
                b = 0.9 - 0.3 * ((val - 0.25) / 0.25)
            elif val < 0.75:
                r = 0.9 + 0.1 * ((val - 0.5) / 0.25)
                g = 0.3 + 0.4 * ((val - 0.5) / 0.25)
                b = 0.6 - 0.5 * ((val - 0.5) / 0.25)
            else:
                r = 1.0
                g = 0.7 + 0.3 * ((val - 0.75) / 0.25)
                b = 0.1 - 0.1 * ((val - 0.75) / 0.25)
            
            lut.SetTableValue(i, r, g, b, 1.0)
        
        lut.Build()
        
        scalar_bar = vtk.vtkScalarBarActor()
        scalar_bar.SetLookupTable(lut)
        scalar_bar.SetTitle("Source Contribution Fraction")
        scalar_bar.SetNumberOfLabels(6)
        scalar_bar.SetMaximumWidthInPixels(100)
        scalar_bar.SetMaximumHeightInPixels(300)
        scalar_bar.SetPosition(0.85, 0.3)
        scalar_bar.SetWidth(0.12)
        scalar_bar.SetHeight(0.4)
        
        text_prop = scalar_bar.GetTitleTextProperty()
        text_prop.SetFontSize(12)
        text_prop.SetColor(1, 1, 1)
        text_prop.SetBold(True)
        
        label_prop = scalar_bar.GetLabelTextProperty()
        label_prop.SetFontSize(10)
        label_prop.SetColor(1, 1, 1)
        
        return scalar_bar, lut
    
    def get_plasma_color(self, fraction):
        """Get plasma RGB color for given fraction (0.1 to 1.0)."""
        if fraction <= 0:
            return (128, 128, 128)
        
        fraction = max(0.1, min(1.0, fraction))
        val = (fraction - 0.1) / 0.9
        
        if val < 0.25:
            r = 0.05 + 0.5 * (val / 0.25)
            g = 0.0
            b = 0.5 + 0.4 * (val / 0.25)
        elif val < 0.5:
            r = 0.55 + 0.35 * ((val - 0.25) / 0.25)
            g = 0.0 + 0.3 * ((val - 0.25) / 0.25)
            b = 0.9 - 0.3 * ((val - 0.25) / 0.25)
        elif val < 0.75:
            r = 0.9 + 0.1 * ((val - 0.5) / 0.25)
            g = 0.3 + 0.4 * ((val - 0.5) / 0.25)
            b = 0.6 - 0.5 * ((val - 0.5) / 0.25)
        else:
            r = 1.0
            g = 0.7 + 0.3 * ((val - 0.75) / 0.25)
            b = 0.1 - 0.1 * ((val - 0.75) / 0.25)
        
        return (int(r * 255), int(g * 255), int(b * 255))

    def on_left_press(self, obj, event):
        """Handle left mouse button press."""
        if not self.selector.selection_active:
            self.OnLeftButtonDown()
        else:
            self.selector.left_button_pressed = True
            click_pos = self.GetInteractor().GetEventPosition()
            if self.selector.Pick(click_pos[0], click_pos[1], 0, self.renderer):
                self.selector.last_position = self.selector.GetCellId()

    def on_left_release(self, obj, event):
        """Handle left mouse button release."""
        if not self.selector.selection_active:
            self.OnLeftButtonUp()
        else:
            self.selector.left_button_pressed = False
            self.selector.last_position = None

    def on_mouse_move(self, obj, event):
        """Handle mouse movement for target selection."""
        if not self.selector.selection_active:
            self.OnMouseMove()
        elif self.selector.left_button_pressed:
            current_time = time()
            if current_time - self.selector.last_update >= self.selector.update_interval:
                click_pos = self.GetInteractor().GetEventPosition()
                if self.selector.Pick(click_pos[0], click_pos[1], 0, self.renderer):
                    current_facet = self.selector.GetCellId()
                    if current_facet >= 0:
                        if self.selector.last_position is not None:
                            facets = self.get_facets_between_points(self.selector.last_position, current_facet)
                        else:
                            facets = self.get_nearby_facets(current_facet)
                        
                        self.selector.selected_targets.update(facets)
                        self.highlight_targets()
                        self.selector.last_update = current_time
                        self.selector.last_position = current_facet
                        self.update_status_text()

    def highlight_targets(self):
        """Highlight selected target facets in green."""
        if not self.selector.selected_targets:
            if self.target_actor:
                self.renderer.RemoveActor(self.target_actor)
                self.target_actor = None
            self.GetInteractor().GetRenderWindow().Render()
            return

        ids = vtk.vtkIdTypeArray()
        ids.SetNumberOfComponents(1)
        for facet_id in self.selector.selected_targets:
            ids.InsertNextValue(facet_id)
            
        selection = vtk.vtkSelectionNode()
        selection.SetFieldType(vtk.vtkSelectionNode.CELL)
        selection.SetContentType(vtk.vtkSelectionNode.INDICES)
        selection.SetSelectionList(ids)
        
        selection_node = vtk.vtkSelection()
        selection_node.AddNode(selection)
        
        extract = vtk.vtkExtractSelection()
        extract.SetInputData(0, self.polydata)
        extract.SetInputData(1, selection_node)
        extract.Update()
        
        geometry_filter = vtk.vtkGeometryFilter()
        geometry_filter.SetInputData(extract.GetOutput())
        geometry_filter.Update()
        
        mapper = vtk.vtkPolyDataMapper()
        mapper.SetInputData(geometry_filter.GetOutput())
        
        if self.target_actor:
            self.renderer.RemoveActor(self.target_actor)
            
        self.target_actor = vtk.vtkActor()
        self.target_actor.SetMapper(mapper)
        self.target_actor.GetProperty().SetColor(0, 1, 0)
        self.target_actor.GetProperty().SetOpacity(0.8)
        self.target_actor.GetProperty().EdgeVisibilityOff()
        
        self.renderer.AddActor(self.target_actor)
        self.GetInteractor().GetRenderWindow().Render()

    def calculate_source_fractions(self):
        """
        Calculate fraction of particles from each source that reach selected targets.
        
        Returns:
            dict: {source_facet_id: fraction}
        """
        if not self.selector.selected_targets:
            print("No targets selected!")
            return {}

        print(f"\nCalculating source contributions to {len(self.selector.selected_targets)} targets...")
        start_time = time()
        
        source_fractions = {}
        targets_set = self.selector.selected_targets
        
        processed = 0
        total_sources = len(self.transport_data)
        report_interval = max(1, total_sources // 20)
        
        for source_id, transport_info in self.transport_data.items():
            if processed % report_interval == 0:
                progress = (processed / total_sources) * 100
                print(f"  Progress: {progress:.1f}%")
            
            destinations = transport_info['destination_facets']
            total_particles = len(destinations)
            
            if total_particles > 0:
                particles_to_targets = sum(1 for dest in destinations if dest in targets_set)
                fraction = particles_to_targets / total_particles
                
                if fraction > 0:
                    source_fractions[source_id] = fraction
            
            processed += 1
        
        elapsed = time() - start_time
        print(f"  Complete in {elapsed:.2f}s")
        print(f"  Found {len(source_fractions)} contributing source facets")
        
        if source_fractions:
            max_frac = max(source_fractions.values())
            avg_frac = sum(source_fractions.values()) / len(source_fractions)
            print(f"  Max: {max_frac:.3f} | Avg: {avg_frac:.3f}")
        
        return source_fractions

    def visualize_sources(self):
        """Visualize source facets with plasma colormap."""
        if not self.source_fractions:
            print("No source data to visualize!")
            return

        print("Creating plasma visualization...")
        
        if self.source_actor:
            self.renderer.RemoveActor(self.source_actor)
        if self.colorbar_actor:
            self.renderer.RemoveActor(self.colorbar_actor)
        
        self.colorbar_actor, lut = self.create_plasma_colorbar()
        
        num_facets = self.polydata.GetNumberOfCells()
        colors = vtk.vtkUnsignedCharArray()
        colors.SetNumberOfComponents(3)
        colors.SetNumberOfTuples(num_facets)
        colors.SetName("FractionColors")
        
        scalars = vtk.vtkFloatArray()
        scalars.SetNumberOfTuples(num_facets)
        scalars.SetName("Fractions")
        
        for facet_id in range(num_facets):
            if facet_id in self.source_fractions:
                fraction = self.source_fractions[facet_id]
                plasma_color = self.get_plasma_color(fraction)
                colors.SetTuple3(facet_id, plasma_color[0], plasma_color[1], plasma_color[2])
                scalar_val = max(0.1, min(1.0, fraction))
                scalars.SetValue(facet_id, scalar_val)
            else:
                colors.SetTuple3(facet_id, 128, 128, 128)
                scalars.SetValue(facet_id, 0.0)
        
        colored_polydata = vtk.vtkPolyData()
        colored_polydata.DeepCopy(self.polydata)
        colored_polydata.GetCellData().SetScalars(colors)
        colored_polydata.GetCellData().AddArray(scalars)
        
        mapper = vtk.vtkPolyDataMapper()
        mapper.SetInputData(colored_polydata)
        mapper.SetScalarModeToUseCellData()
        mapper.SetLookupTable(lut)
        mapper.SetScalarRange(0.1, 1.0)
        
        self.source_actor = vtk.vtkActor()
        self.source_actor.SetMapper(mapper)
        self.source_actor.GetProperty().EdgeVisibilityOff()
        
        if self.main_actor:
            self.renderer.RemoveActor(self.main_actor)
        
        self.renderer.AddActor(self.source_actor)
        self.renderer.AddActor(self.colorbar_actor)
        self.visualization_active = True
        
        print(f"Visualization complete! Colored {len(self.source_fractions):,} facets")
        
        self.GetInteractor().GetRenderWindow().Render()

    def reset_visualization(self):
        """Reset to original gray surface view."""
        if self.source_actor:
            self.renderer.RemoveActor(self.source_actor)
            self.source_actor = None
        
        if self.colorbar_actor:
            self.renderer.RemoveActor(self.colorbar_actor)
            self.colorbar_actor = None
        
        if self.main_actor:
            self.renderer.AddActor(self.main_actor)
        
        self.visualization_active = False
        self.GetInteractor().GetRenderWindow().Render()

    def update_status_text(self):
        """Update on-screen status display."""
        mode_status = "ON" if self.selector.selection_active else "OFF"
        vis_status = "ON" if self.visualization_active else "OFF"
        
        message = (
            f"Velocity: {self.velocity} m/s\n"
            f"Target Selection: {mode_status}\n"
            f"Source Visualization: {vis_status}\n"
            f"Brush Size: {self.selector.brush_radius:.3f}\n"
            f"Selected Targets: {len(self.selector.selected_targets)}\n"
            f"Source Facets: {len(self.source_fractions)}\n\n"
            f"Controls:\n"
            f"'p' - Toggle target selection\n"
            f"'c' - Clear targets\n"
            f"'v' - Calculate & visualize\n"
            f"'r' - Reset view\n"
            f"'['/']' - Brush size\n"
            f"'s' - Save results"
        )
        
        self.text_actor.SetInput(message)
        self.GetInteractor().GetRenderWindow().Render()

    def save_selection(self):
        """Save target selection and source contributions to CSV."""
        if not self.selector.selected_targets:
            print("No targets selected!")
            return

        timestamp = time.strftime("%Y%m%d_%H%M%S")
        velocity_str = f"v{int(self.velocity * 10):02d}"
        
        target_filename = f"target_selection_{velocity_str}_{timestamp}.csv"
        with open(target_filename, 'w', newline='') as f:
            writer = csv.writer(f)
            writer.writerow(['target_facet_id'])
            for facet_id in sorted(self.selector.selected_targets):
                writer.writerow([facet_id])
        
        print(f"Saved targets: {target_filename}")
        
        if self.source_fractions:
            source_filename = f"source_contributions_{velocity_str}_{timestamp}.csv"
            with open(source_filename, 'w', newline='') as f:
                writer = csv.writer(f)
                writer.writerow(['source_facet_id', 'fraction', 'percentage'])
                for facet_id, fraction in sorted(self.source_fractions.items()):
                    writer.writerow([facet_id, fraction, fraction*100])
            
            print(f"Saved sources: {source_filename}")

# ============================================================================
# Main Function
# ============================================================================

def main():
    """Run interactive reverse trajectory visualizer."""
    
    print("=" * 70)
    print("INTERACTIVE REVERSE TRAJECTORY VISUALIZER - COMET 67P")
    print("=" * 70)
    
    velocity = float(input("Enter ejection velocity (0.1-0.9 m/s): "))
    if not (0.1 <= velocity <= 0.9):
        print("Error: Velocity must be between 0.1 and 0.9 m/s")
        return
    
    print(f"\nInitializing visualizer for velocity {velocity} m/s...")
    
    renderer = vtk.vtkRenderer()
    renderer.SetBackground(0.1, 0.1, 0.1)
    
    window = vtk.vtkRenderWindow()
    window.AddRenderer(renderer)
    window.SetSize(1200, 800)
    window.SetWindowName(f"Comet 67P - Reverse Trajectory ({velocity} m/s)")
    
    interactor = vtk.vtkRenderWindowInteractor()
    interactor.SetRenderWindow(window)
    
    print(f"Loading shape model from {SHAPE_MODEL_FILE}...")
    reader = vtk.vtkOBJReader()
    reader.SetFileName(SHAPE_MODEL_FILE)
    reader.Update()
    polydata = reader.GetOutput()
    
    print(f"Loaded: {polydata.GetNumberOfCells():,} facets")
    
    mapper = vtk.vtkPolyDataMapper()
    mapper.SetInputData(polydata)
    main_actor = vtk.vtkActor()
    main_actor.SetMapper(mapper)
    main_actor.GetProperty().SetColor(0.8, 0.8, 0.8)
    main_actor.GetProperty().EdgeVisibilityOff()
    renderer.AddActor(main_actor)
    
    text_actor = vtk.vtkTextActor()
    text_property = text_actor.GetTextProperty()
    text_property.SetFontSize(16)
    text_property.SetColor(1.0, 1.0, 1.0)
    renderer.AddActor2D(text_actor)
    
    selector = TargetSelector()
    selector.SetPickFromList(1)
    selector.AddPickList(main_actor)
    selector.PickFromListOn()
    
    try:
        visualizer = ReverseTrajectoryVisualizer(selector, renderer, polydata, 
                                                text_actor, velocity)
        visualizer.main_actor = main_actor
        interactor.SetInteractorStyle(visualizer)
        
        def handle_key(obj, event):
            key = obj.GetKeySym()
            if key == 'p':
                selector.selection_active = not selector.selection_active
                if not selector.selection_active:
                    visualizer.reset_visualization()
                visualizer.update_status_text()
            elif key == 'c':
                selector.selected_targets.clear()
                visualizer.source_fractions.clear()
                visualizer.highlight_targets()
                visualizer.reset_visualization()
                visualizer.update_status_text()
            elif key == 'v':
                if selector.selected_targets:
                    visualizer.source_fractions = visualizer.calculate_source_fractions()
                    visualizer.visualize_sources()
                    visualizer.update_status_text()
                else:
                    print("Select targets first (press 'p' to enable selection)")
            elif key == 'r':
                visualizer.reset_visualization()
                visualizer.update_status_text()
            elif key == 'bracketright':
                selector.brush_radius += 0.02
                visualizer.update_status_text()
            elif key == 'bracketleft':
                selector.brush_radius = max(0.01, selector.brush_radius - 0.02)
                visualizer.update_status_text()
            elif key == 's':
                visualizer.save_selection()
            
            window.Render()
        
        interactor.AddObserver("KeyPressEvent", handle_key)
        
        visualizer.update_status_text()
        print("\nVisualization ready!")
        print("Press 'p' to start selecting target facets\n")
        
        window.Render()
        interactor.Start()
        
    except FileNotFoundError as e:
        print(f"\nERROR: Required file not found: {e}")
        print("\nEnsure you have:")
        print(f"1. {SPATIAL_INDEX_FILE}")
        print(f"2. transport_dict_velocity_0x_shapemodel.pkl in {TRANSPORT_DICT_DIR}/")
        print(f"3. {SHAPE_MODEL_FILE}")
    except Exception as e:
        print(f"\nERROR: {e}")
        import traceback
        traceback.print_exc()

if __name__ == '__main__':
    main()